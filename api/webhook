// PayPal webhook verification
function verifyPayPalWebhook(payload, headers, webhookId) {
  try {
    const transmission_id = headers["paypal-transmission-id"]
    const cert_id = headers["paypal-cert-id"]
    const auth_algo = headers["paypal-auth-algo"]
    const transmission_sig = headers["paypal-transmission-sig"]
    const transmission_time = headers["paypal-transmission-time"]

    // For production, you'd verify the signature properly
    // This is a simplified version for demo purposes
    return transmission_id && cert_id && auth_algo && transmission_sig
  } catch (error) {
    console.error("Webhook verification error:", error)
    return false
  }
}

// Extract player information from PayPal payment
function extractPlayerInfo(paymentData) {
  try {
    // Extract player name from custom field or item name
    let playerName = "Unknown Player"

    // Try to get from custom field first
    if (paymentData.custom) {
      playerName = paymentData.custom
    } else if (paymentData.item_name) {
      // Extract from item name if it contains "Player: Name"
      const match = paymentData.item_name.match(/Player:\s*([^-]+)/)
      if (match) {
        playerName = match[1].trim()
      }
    }

    // Get payer information
    const payerEmail = paymentData.payer_email || paymentData.payer?.payer_info?.email || ""
    const amount = Number.parseFloat(paymentData.mc_gross || paymentData.amount?.total || "0")
    const seats = Math.max(1, Math.floor(amount / 10)) // $10 per seat

    return {
      id: paymentData.txn_id || paymentData.id || Date.now().toString(),
      playerName: playerName,
      email: payerEmail,
      amount: amount.toFixed(2),
      seats: seats,
      timestamp: new Date().toISOString(),
      status: "confirmed",
      paymentStatus: paymentData.payment_status || "Completed",
    }
  } catch (error) {
    console.error("Error extracting player info:", error)
    return null
  }
}

// Main webhook handler
export default async function handler(req, res) {
  // Set CORS headers
  res.setHeader("Access-Control-Allow-Origin", "*")
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS")
  res.setHeader(
    "Access-Control-Allow-Headers",
    "Content-Type, paypal-transmission-id, paypal-cert-id, paypal-auth-algo, paypal-transmission-sig, paypal-transmission-time",
  )

  if (req.method === "OPTIONS") {
    return res.status(200).end()
  }

  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" })
  }

  try {
    const webhookId = process.env.PAYPAL_WEBHOOK_ID

    if (!webhookId) {
      console.error("PAYPAL_WEBHOOK_ID not configured")
      return res.status(500).json({ error: "Webhook ID not configured" })
    }

    // Verify webhook authenticity
    if (!verifyPayPalWebhook(req.body, req.headers, webhookId)) {
      console.error("Webhook verification failed")
      return res.status(401).json({ error: "Unauthorized" })
    }

    const payload = req.body
    console.log("Received webhook:", payload.event_type || payload.txn_type)

    // Handle different PayPal webhook events
    let playerInfo = null

    if (payload.event_type === "PAYMENT.SALE.COMPLETED" || payload.txn_type === "web_accept") {
      // Extract payment data based on webhook type
      const paymentData = payload.resource || payload
      playerInfo = extractPlayerInfo(paymentData)

      if (playerInfo && playerInfo.paymentStatus === "Completed") {
        console.log("Player registered:", playerInfo)

        // In a real implementation, you'd save to a database here
        // For now, we'll return the player info to be handled by the frontend

        return res.status(200).json({
          success: true,
          message: "Player registered successfully",
          player: playerInfo,
        })
      }
    }

    // For other event types or incomplete payments
    return res.status(200).json({
      success: true,
      message: "Webhook received but no action taken",
      eventType: payload.event_type || payload.txn_type,
    })
  } catch (error) {
    console.error("Webhook processing error:", error)
    return res.status(500).json({
      error: "Internal server error",
      message: error.message,
    })
  }
}

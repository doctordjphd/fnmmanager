// Ensure this endpoint is publicly accessible
export const config = {
  api: {
    bodyParser: {
      sizeLimit: "1mb",
    },
  },
}

// Make sure this runs without authentication
export const runtime = "nodejs"

// PayPal webhook verification
function verifyPayPalWebhook(payload, headers, webhookId) {
  try {
    const transmission_id = headers["paypal-transmission-id"]
    const cert_id = headers["paypal-cert-id"]
    const auth_algo = headers["paypal-auth-algo"]
    const transmission_sig = headers["paypal-transmission-sig"]
    const transmission_time = headers["paypal-transmission-time"]

    // For production, you'd verify the signature properly
    // This is a simplified version for demo purposes
    return transmission_id && cert_id && auth_algo && transmission_sig
  } catch (error) {
    console.error("Webhook verification error:", error)
    return false
  }
}

// Extract player information from PayPal payment
function extractPlayerInfo(paymentData) {
  try {
    // Get player name from PayPal payer information
    let playerName = "Unknown Player"

    // PayPal provides name in different formats depending on webhook type
    if (paymentData.payer) {
      // For newer webhook format
      const payer = paymentData.payer.payer_info || paymentData.payer
      if (payer.first_name && payer.last_name) {
        playerName = `${payer.first_name} ${payer.last_name}`
      } else if (payer.payer_name) {
        playerName = payer.payer_name
      }
    } else if (paymentData.first_name && paymentData.last_name) {
      // For IPN format
      playerName = `${paymentData.first_name} ${paymentData.last_name}`
    } else if (paymentData.payer_name) {
      playerName = paymentData.payer_name
    }

    // Get payer email
    const payerEmail =
      paymentData.payer_email || paymentData.payer?.payer_info?.email || paymentData.payer?.email_address || ""

    const amount = Number.parseFloat(paymentData.mc_gross || paymentData.amount?.total || "0")
    const seats = Math.max(1, Math.floor(amount / 10)) // $10 per seat

    return {
      id: paymentData.txn_id || paymentData.id || Date.now().toString(),
      playerName: playerName.trim(),
      email: payerEmail,
      amount: amount.toFixed(2),
      seats: seats,
      timestamp: new Date().toISOString(),
      status: "confirmed",
      paymentStatus: paymentData.payment_status || "Completed",
    }
  } catch (error) {
    console.error("Error extracting player info:", error)
    return null
  }
}

// Main webhook handler
export default async function handler(req, res) {
  // Set CORS headers
  res.setHeader("Access-Control-Allow-Origin", "*")
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS")
  res.setHeader("Access-Control-Allow-Headers", "Content-Type")

  if (req.method === "OPTIONS") {
    return res.status(200).end()
  }

  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" })
  }

  try {
    console.log("Webhook received:", req.body)

    return res.status(200).json({
      success: true,
      message: "Webhook received",
      timestamp: new Date().toISOString(),
    })
  } catch (error) {
    console.error("Webhook error:", error)
    return res.status(500).json({ error: "Internal server error" })
  }
}
